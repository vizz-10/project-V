<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Call — Vizz</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="container">
    <div class="card">
      <h2>Call</h2>
      <div class="row"><div id="roomInfo"></div><button id="endBtn">End Room</button></div>
    </div>
    <div class="card videos">
      <div style="flex:1"><h4>Local</h4><video id="localVideo" autoplay muted playsinline></video></div>
      <div style="flex:1"><h4>Remote</h4><video id="remoteVideo" autoplay playsinline></video></div>
    </div>
    <div class="card"><h3>Translation</h3><div id="translationBox">—</div></div>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script>
    const socket = io();
    const token = localStorage.getItem('token');
    const room = localStorage.getItem('currentRoom');
    const callTarget = localStorage.getItem('callTarget') || '';
    const roomInfo = document.getElementById('roomInfo');
    const endBtn = document.getElementById('endBtn');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const translationBox = document.getElementById('translationBox');
    roomInfo.textContent = 'Room: ' + room + (callTarget ? ' → ' + callTarget : '');

    let localStream, pc, startTime;

    async function startLocal(){ localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true}); localVideo.srcObject = localStream; }

    function createPC(){
      const pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
      pc.ontrack = e => remoteVideo.srcObject = e.streams[0];
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
      return pc;
    }

    async function init(){
      await startLocal();
      pc = createPC();
      socket.emit('join-room', room, {});
      socket.on('peer-joined', async ({id})=>{
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('signal', { to: id, from: socket.id, signal: { type:'offer', sdp: offer.sdp } });
      });
      socket.on('signal', async (data)=>{
        const s = data.signal;
        if(s.type==='offer'){
          await pc.setRemoteDescription({type:'offer', sdp: s.sdp});
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal',{ to: data.from, from: socket.id, signal:{type:'answer', sdp: answer.sdp} });
        } else if(s.type==='answer'){
          await pc.setRemoteDescription({type:'answer', sdp: s.sdp});
        }
      });
      socket.on('call-ended', async (data)=>{
        alert('Call ended');
        cleanupAndReturn(data);
      });
      startTime = new Date();
      initMediaPipe();
    }

    endBtn.onclick = async ()=>{
      const endTime = new Date();
      try{
        const meRes = await fetch('/api/user/me', { headers: { 'Authorization': 'Bearer ' + token } }).then(r=>r.json());
        const caller = meRes.user.email;
        const receiver = callTarget || 'unknown';
        await fetch('/api/calls/end', { method:'POST', headers: {'Content-Type':'application/json','Authorization':'Bearer '+token}, body: JSON.stringify({ caller, receiver, roomId: room, startTime: startTime, endTime: endTime }) });
      }catch(e){ console.error(e); }
      socket.emit('end-call', { roomId: room });
      cleanupAndReturn();
    };

    function cleanupAndReturn(data){
      if(pc) pc.close();
      if(localStream){ localStream.getTracks().forEach(t=>t.stop()); }
      localStorage.removeItem('currentRoom');
      localStorage.removeItem('callTarget');
      window.location.href = '/';
    }

    function initMediaPipe(){
      const hands = new Hands({locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
      hands.setOptions({maxNumHands:1,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
      hands.onResults(onResults);
      const cam = new Camera(localVideo, { onFrame: async ()=>{ await hands.send({image: localVideo}); }, width:640, height:480 });
      cam.start();
    }

    function onResults(results){
      if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0){ translationBox.textContent='No hand'; return; }
      const lm = results.multiHandLandmarks[0];
      const wrist = lm[0];
      const tips = [lm[4],lm[8],lm[12],lm[16],lm[20]];
      const avg = tips.reduce((s,t)=>s+Math.hypot(t.x-wrist.x,t.y-wrist.y),0)/tips.length;
      if(avg>0.35) translationBox.textContent='Open hand — hello';
      else if(avg>0.18) translationBox.textContent='Some fingers — yes/no';
      else translationBox.textContent='Fist — stop';
    }

    init();
  </script>
</body>
</html>
